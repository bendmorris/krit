#include "krit/script/ScriptClass.h"
#include "krit/script/ScriptEngine.h"
#include "quickjs.h"
#include <string>

{% for wrapper in wrappers %}

{% for import in wrapper.import %}
#include "{{ import }}"
{% endfor %}

namespace {{wrapper.namespace}} {

{% for prop in wrapper.props %}
static JSValue js_{{wrapper.name}}_get_{{ prop.name }}(JSContext *ctx, JSValueConst this_val) {
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    {{ wrapper.name }} *p = static_cast<{{ wrapper.name }}*>(JS_GetOpaque2(ctx, this_val, engine->classIds[ScriptClass{{ wrapper.name }}]));
    if (!p) {
        return JS_EXCEPTION;
    }
    {% if prop.tags.getter %}
    const {{ prop.cppType.type }} &v = {% if prop.pointer %}&{{ '*' | repeat(prop.cppType.pointer) }}{% endif %}p->{{ prop.tags.getter }}();
    {% else %}
    const {{ prop.cppType.type }} &v = {% if prop.pointer %}&{% endif %}{{ '*' | repeat(prop.cppType.pointer) }}p->{{ prop.name }};
    {% endif %}
    return ScriptValue<{{ prop.cppType.type }}>::valueToJs(ctx, v);
}

{% if not prop.tags.readonly %}
static JSValue js_{{wrapper.name}}_set_{{ prop.name }}(JSContext *ctx, JSValueConst this_val, JSValue val) {
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    {{ wrapper.name }} *p = static_cast<{{ wrapper.name }}*>(JS_GetOpaque2(ctx, this_val, engine->classIds[ScriptClass{{ wrapper.name }}]));
    if (!p) {
        return JS_EXCEPTION;
    }
    {% if prop.tags.getter %}
    p->{{ prop.tags.getter }}() =
    {% else %}
    p->{{ prop.name }} =
    {% endif %}
        {% if prop.tags.cast %}static_cast<{{ prop.tags.cast }}>({% endif %}ScriptValue<{{ prop.cppType.type }}{{ '*' | repeat(prop.cppType.pointer) }}>::jsToValue(ctx, val){% if prop.tags.cast %}){% endif %};
    return JS_UNDEFINED;
}
{% endif %}
{% endfor %}

{% for method in wrapper.methods %}
static JS_FUNC({{wrapper.name}}_{{ method.name }}) {
{% if method.tags.convert %}
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    void *p = JS_GetOpaque2(ctx, this_val, engine->classIds[ScriptClass{{ wrapper.name }}]);
    JSValue finalizerSymbol = JS_GetPropertyStr(ctx, this_val, "__finalizerSymbol");
    JSAtom atom = JS_ValueToAtom(ctx, finalizerSymbol);
    JSValue val = engine->createOwned(ScriptClass{{ method.returnCppType.type }}, p);
    if (!JS_IsUndefined(finalizerSymbol) && JS_HasProperty(ctx, this_val, atom)) {
        JSValue finalizer = JS_GetProperty(ctx, this_val, atom);
        JS_SetProperty(ctx, val, atom, JS_DupValue(ctx, finalizer));
        JS_DeleteProperty(ctx, this_val, atom, 0);
    }
    return val;
{% else %}
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    {{ wrapper.name }} *p = static_cast<{{ wrapper.name }}*>(JS_GetOpaque2(ctx, this_val, engine->classIds[ScriptClass{{ wrapper.name }}]));
    {% set comma = joiner() %}
    {% if method.returnCppType %}auto {% if method.returnCppType.reference %}&{% endif %}rt = {% endif %}p->{{method.name}}(
        {% for param in method.params %}
        {{ comma() }} {% if param.cppType.reference %}*{% endif %}ScriptValue<{{ param.cppType.type }}{{ '*' | repeat(param.cppType.pointer) }}{% if param.cppType.reference %}*{% endif %}>::jsToValue(ctx, argv[{{ loop.index - 1 }}])
        {% endfor %}
    );
    {% if method.returnCppType %}
    return ScriptValue<{{ method.returnCppType.type }}{{ '*' | repeat(method.returnCppType.pointer) }}>::valueToJs(ctx, rt);
    {% else %}
    return JS_UNDEFINED;
    {% endif %}
{% endif %}
}
{% endfor %}

}

namespace krit {

static const JSCFunctionListEntry protoFuncs{{ wrapper.name }}[] = {
    {% for prop in wrapper.props %}
    JS_CGETSET_DEF("{{ prop.name }}", {{ wrapper.namespace }}::js_{{wrapper.name}}_get_{{ prop.name }}, {% if prop.tags.readonly %} nullptr {% else %} {{ wrapper.namespace }}::js_{{wrapper.name}}_set_{{ prop.name }} {% endif %}),
    {% endfor %}
    {% for method in wrapper.methods %}
    JS_CFUNC_DEF("{{ method.name }}", {{ method.params.length }}, {{ wrapper.namespace }}::js_{{ wrapper.name }}_{{ method.name }}),
    {% endfor %}
};

static JSClassDef classDef{{wrapper.name}} = {
    "{{ wrapper.name }}",
    .finalizer = nullptr,
};

template <> std::pair<const JSCFunctionListEntry *, size_t> scriptClassProtoFuncs<ScriptClass{{ wrapper.name }}>() {
    return std::make_pair(protoFuncs{{ wrapper.name }}, countof(protoFuncs{{ wrapper.name }}));
}

template <> JSClassDef *scriptClassDef<ScriptClass{{ wrapper.name }}>() {
    return &classDef{{ wrapper.name }};
}

{% if not wrapper.pointerOnly %}
template <> JSValue ScriptValue<{{ wrapper.namespace }}::{{ wrapper.name }}>::valueToJs(JSContext *ctx, {{ wrapper.namespace }}::{{ wrapper.name }} const &arg) {
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    JSValue val = JS_NewObjectClass(ctx, engine->classIds[ScriptClass{{ wrapper.name }}]);
    JS_SetOpaque(val, (void*)&arg);
    return val;
}
template <> {{ wrapper.namespace }}::{{ wrapper.name }} ScriptValue<{{ wrapper.namespace }}::{{ wrapper.name }}>::jsToValue(JSContext *ctx, JSValue val) {
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    return *static_cast<typename {{ wrapper.namespace }}::{{ wrapper.name }}*>(JS_GetOpaque2(ctx, val, engine->classIds[ScriptClass{{ wrapper.name }}]));
}
{% endif %}
template <> JSValue ScriptValue<{{ wrapper.namespace }}::{{ wrapper.name }}*>::valueToJs(JSContext *ctx, {{ wrapper.namespace }}::{{ wrapper.name }}* const &arg) {
    if (!arg) {
        return JS_UNDEFINED;
    }
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    JSValue val = JS_NewObjectClass(ctx, engine->classIds[ScriptClass{{ wrapper.name }}]);
    JS_SetOpaque(val, (void*)arg);
    return val;
}
template <> {{ wrapper.namespace }}::{{ wrapper.name }} *ScriptValue<{{ wrapper.namespace }}::{{ wrapper.name }}*>::jsToValue(JSContext *ctx, JSValue val) {
    ScriptEngine *engine = static_cast<ScriptEngine*>(JS_GetContextOpaque(ctx));
    return static_cast<typename {{ wrapper.namespace }}::{{ wrapper.name }}*>(JS_GetOpaque2(ctx, val, engine->classIds[ScriptClass{{ wrapper.name }}]));
}


}

{% endfor %}
